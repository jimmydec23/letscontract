// SPDX-License-Identifier: SEE LICENSE IN LICENSE
pragma solidity ^0.8.9;

/// @notice Each new term in the Fibonacci sequence is generated by adding
/// the previous two terms. By starting with 1 and 2, the first 10
/// terms will be as follows:
/// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
/// By considering the terms in the Fibonacci sequence whose values
/// do not exceed 4 million, find the sum of the even-valued terms.
contract CommitRevealPuzzle {
    // the duration of guessing period in blocks
    uint public constant GUESS_DURATION_BLOCKS = 5;

    // the duration of reveal period
    uint public constant REVEAL_DURATION_BLOCKS = 5;

    // contract creator
    address public creator;

    // the block number corresponding to the end of the guessing period
    uint public guessDeadline;

    // the block number corresponding to the end of the reveal period
    uint public revealDeadline;

    // the value of prize in wei
    uint public totalPrize;

    // mapping from player address to there commitments
    mapping (address => bytes32) public commitments;

    // list of winner address
    address[] public winners;

    // to mark winning claimed or not
    mapping(address => bool) public claimed;

    /// @notice creator deploy contract with the correct answer commitment
    constructor(bytes32 _commitment) payable {
        creator = msg.sender;
        commitments[creator] = _commitment;
        guessDeadline = block.number + GUESS_DURATION_BLOCKS;
        revealDeadline = guessDeadline + REVEAL_DURATION_BLOCKS;
        totalPrize += msg.value;
    }

    /// @notice create commitment by hashing user address and answer
    function createCommitment(address user, uint answer) public pure returns (bytes32){
        return keccak256(abi.encode(user, answer));
    }

    /// @notice player submit his commitment
    function guess(bytes32 _commitment) public {
        require(block.number < guessDeadline);
        require(msg.sender != creator);
        commitments[msg.sender] = _commitment;
    }

    /// @notice Check if the anser is correct. Some block number limits is 
    /// required. Player must pay to submit the commitment using guess function,
    /// so the commitment was recorded. if ths hash of with the answer and 
    /// creator's address match the commitment recorded at deploy, then record
    /// the sender address to the winner list.
    function reveal(uint answer) public {
        require(block.number >= guessDeadline);
        require(block.number < revealDeadline);
        require(createCommitment(msg.sender, answer) == commitments[msg.sender]);
        require(createCommitment(creator, answer) == commitments[creator]);
        require(!isWinner(msg.sender));
        winners.push(msg.sender);
    }

    /// @notice winner claim their reword
    function claim() public {
        require(block.number > revealDeadline);
        require(claimed[msg.sender] = false);
        require(isWinner(msg.sender));
        uint payout = totalPrize / winners.length;
        claimed[msg.sender] = true;
        payable(msg.sender).transfer(payout);
    }

    /// @notice check if user is winner
    function isWinner(address user) public view returns (bool) {
        bool winner = false;
        for (uint i=0; i < winners.length; i++){
            if(winners[i] == user) {
                winner = true;
                break;
            }
        }
        return winner;
    }

    fallback() payable external {}
    receive() payable external {}
}